# C++

C++ is a low-level powerful programming language.

## Basics

* Anything prepended with a `#` is preprocess statement, which are processed by
a compiler right before compiling.
* The main function specifies a return type, but a return isn't required and
defaults to return 0.
* It is important to remember that files do not matter in C++, unlike languages
like Java where class names are tied to their file names. All files do in C++ is
feed the compiler source code.
* Declarations are stored in header files, and definitions are stored in C++
files.

### The Compiler & Linker

There are two steps to make a text file into a runnable program:

#### Compiling

Converts C++ code into an intermediate format known as an object file (one for
each C++ file).

1. Compilation starts by proprocessing the code (evaluating preprocess
statements) i.e. `#include`, `#define`, `#if`, `#ifndef`, `#pragma`
    * #include - just copies and pastes whatever was in that header file.
    * #define - replaces the all found cases of the first argument with the
    second
    * #if/#endif - include/exclude code in compilation based on a condition
    * #ifndef/#endif - checks if there is a symbol defined from `#define`
    * #pragma - instruction sent to the preprocessor, `#pragma once` means to
    only include this file once in a single object file
1. Tokenize/Parse into an abstract syntax tree (which the compiler can
understand more easily)

The object files when opened just display binary, but you tell the compiler to
generate Asembly or other file types while compiling.

Compiler settings can also be user defined, by default, the compiler knowns how
to compile files based on extension. You can tell the compiler to compile `.foo`
files as C++ files and it will work just fine.

> Compilation errors are prepended with with a C.

#### Linking

Links the objects files generated by the compiler together (by resolving symbol
and function locations) into a runnable program.

Since files are not important in C++, and all object files get linked
together, this can cause some issues:

1. Having a function in a header file included in two other files will producea
linking error due to duplicate function names.
    * To fix this, `static` marks that symbol/function visible to only that
    object file.
    * Using `inline` marks that symbol/function to replace the calls with the
    symbol/function body.
    * Best method is to include the symbol/function definition in a C++ file to
    be used and use a declaraction in other files using that symbol/function.

> Linking errors are prepended with an L.

#### Declaractions & Defintions

* Declaraction - function signature to tell the compiler it exists in another
object file
* Definition - the actual function body

It is possible to compile code while having a definition in another C++ file, as
long as a declaration is made (A promise to the compiler that this function does
exist).

main.cpp

```cpp
void Hello(const char* message); // Declaraction
extern int globalVar; // External linking of a variable outside this file.

int main() {
    Hello("Jerry");
    std::cout << globalVar << std::endl;
}
```

hello.cpp

```cpp
#include <iostream>

int globalVar = 5; // Variable definition

// Definition
void Hello(const char* name) {
    std::cout << "Hello " << name << "!" << std::endl;
}

// Produces a
// void Hellow(const char* name) {
//     std::cout << "Hello " << name << "!" << std::endl;
// }
```

This is where the linker comes in, since there is an object file generated for
each C++ file, the linker links these object files together. However, if a
definition isn't found by the linker, this results in a **Linker Error**.

## Variables

Variables are strongly typed (needs to include data type).

`int number = 4;`

> int is 4 bytes = 32bits - 1 signed bit = 2(possible states)^31bits = ‭2,147,483,648‬ (int limit)

To completely remove the use of the signed bit, use `unsigned`

`unsigned int number = 4;`

Common types:

* `char` - 1 byte
* `short` - 2 bytes
* `int` - 4 bytes
* `long` - 4 bytes (depending on compiler)
* `long long` - 8 bytes
* `float` - 4 bytes (treated as a double unless prepended with `f`)
* `double` - 8 bytes
* `bool` - 1 byte

> Even though booleans can be stored in one bit, it occupies a byte since when
addressing memory, we can only address bytes, not bits. Nice little hack, it is
possible to store 8 bools in one byte!

### Pointers

A pointer is just an integer in hexadecimal format that holds a memory address.
Types don't matter with pointers. A pointer for all types is just the integer
that holds the memory address. Giving a pointer a type is telling the programmer
that the data in that address is presumed to be that type. It has no effect on\
what the pointer is: **an integer memory address**.

Simple pointer:

```c++
/* These are all the same. */

void* ptr = 0; // Not a valid memory address.
void* ptr2 = NULL; // #define value for 0.
void* ptr3 = nullptr; // Value introduced in C++11.
```

To grab the memory address of a variable, you use the `&` operator. If you want to access the
data, you would use the `*` to **dereference** the pointer (gain access to read and write to
that data). This is where types are also important, the compiler needs to know, how many bytes
can be written. An int pointer tells the compiler that there's 4 bytes there.

```c++
int num = 12;

int* numPtr = &num; // This is a memory address to 4 bytes.

// Dereference the pointer
*numPtr = 7;
```

Since pointers themeselves are integer variables representing a memory address, they also take
up memory. Therefore, the pointer itself has a memory address that can also be stored as a
pointer. This is where _double pointers_ come in.

```c++
int num = 5; // holds 5
int* numPtr = &num; // holds the value 0x61ff04 which -> 5
int** numPtrPtr = &numPtr; // holds the value 0x61ff00 which -> 04 ff 61 00 (0x61ff04)
```

Other useful examples with pointers:

```c++
// Chars are 1 bytes, but this is asking for 8 bytes and holding the memory address of the first byte
char* buffer = new char[8];

// memset fills a block of memory with data.
memset(buffer /*pointer*/, 0 /*What data*/, 8 /*How many bytes*/);

// Deletes the memory at that address using array notation (buffer was made with an array).
delete[] buffer;
```

### References

References are pointers in disguise. It's not really a variable that takes up memory. It's
mostly syntatic sugar to alias a variable.

```c++
int a = 5;
int& ref = a;
ref = 2;

std::cout << a << std::endl; // Prints 2.
```

A simple example of why this is useful:

```c++
void Increment(int value) {
    value++;
}

void IncrementWithPtr(int* value) {
    // value++; // Increments the memory address
    // *value++; // Increments the memory address then dereferences the pointer (Order of operations)
    (*value)++; // Correct
}

void IncrementWithRef(int& value) {
    value++;
}

int main() {
    int a = 5;
    // Passing variable by value, it is copied then incremented.
    Increment(a);
    std::cout << a << std::endl; // Prints 5.

    // Passing by reference using pointers.
    IncrementWithPtr(&a);
    std::cout << a << std::endl; // Prints 6.

    // Using references (no need to send memory address, dereferance, and looks cleaner)
    IncrementWithRef(a);
    std::cout << a << std::endl; // Prints 6.
}
```

References are just aliases, not actual values. Everything you can do with a reference can be
done with a pointer. Pointers are just more powerful, but it's recommended to use references
when you can get away with using them.

> Once a reference is declared, what it references cannot be changed.

```c++
int a = 1;
int b = 5;

int& ref = a;
ref = b; // a = 5, b = 5

// Pointers make this behaviour possible.
int* ptr = &a; // *ptr = 1
ptr = &b; // *ptr = 5
```

## Conditionals

Syntax:

```cpp
if(condition) {
    // code
}
else if(condition) {
    // code
}
else {
    // code
}

// What really happens with 'else if'

if(condition) {

}
else {
    if(condition) {

    }
}
```

Conditional operators: `== != < > <= >= && || !`

## Collections

## Loops

C++ supports `while`, `do while`, and `for` loops.

while syntax:

```cpp
int i = 0;
while(i < 10) {
    // code
    i++;
}


```

do while syntax

```cpp
int i = 0;
do {
    // code
    i++;
} while(i < 10);

```

for syntax:

```cpp
for(int i = 0; i < 10; i++) {
    // code
}

// These also work
int i = 0;
for( ; i < 10 ; ) {
    // code
    i++;
}

int i = 0;
bool condition = i < 10;
for( ; condition ; ) {
    // code
    i++;
}
```

Control flow statements are used with loops to affect the flow of the loop.

* `break` - end the loop
* `continue` - go to the next iteration if there is, otherwise finish the loop.
* `return` - exits the function
* `goto` -

## I/O

## Functions

Syntax:

```cpp
void myFunction(int param1, int param2) {
    // code
}

myFunction();
```

## Exceptions

## Classes & Objects

Classes and objects allow for a type of programming known as Object Oriented Programming. They
allow for the grouping of data and functionality. C does not support OOP, however, C++ added
those features. It's important to keep in mind that anything you can do with classes can be done
without classes. Hence why C is still a usable language. Classes just make code easier to
organize and maintain.

Simple class example:

```c++
class Player {

    // Class members are private by default.
    int x, y;
    int speed;

    void position() {
        std::cout << posX << ", " << posY << std::endl;
    }

};
```

### Access Modifiers

Access modifiers affect both class fields and methods. They can be placed
in more than one place in the class declaration, it depends on the programmers
style.

```c++
class Player {

public:
    int posX = 3;
    int posY = 4;
private:
    int p_SpeedX = 1;
    int p_SpeedY = 2;

public:
    void position() {
        std::cout << posX << ", " << posY << std::endl;
    }

private:
    void adjustSpeed() {
        // code
    }
};

int main() {
    Player player;
    player.posX = 5;

    player.position();
}
```

### Constructors

Constructors are methods called when you initialize and object. There is a
default constructor provided, but it's just a method with an empty body.

```c++
class Player {

public:
    int posX;
    int posY;
private:
    int p_SpeedX = 1;
    int p_SpeedY = 2;

public:
    // Constructor.
    Player(int x, int y) {
        posX = x;
        posY = y;
    }

    void position() {
        std::cout << posX << ", " << posY << std::endl;
    }

private:
    void adjustSpeed() {
        // code
    }
};

int main() {
    Player player(3, 4);
    player.position();
}
```

There is a way to remove constructor functionality from a class (common for
classes with only static methods, where objects don't need to be instantiated)

You can make the constructor private or use the `delete` keyword.

```c++
class Log {
// Method 1.
private:
    Log() {}
public:
    // Method 2
    Log() = delete;
    void Write() {

    }
}
```

#### Copy Constructors

#### Move Constructors

### Destructors

Destructors are called when an object gets destroyed. It's used for preventing
memory leaks. Best practice is to uninitialize everything that was initialized in
the constructor.

```c++
class Player {

public:
    int posX = 3;
    int posY = 4;
private:
    int p_SpeedX = 1;
    int p_SpeedY = 2;

public:
    // Constructor.
    Player(int x, int y) {
        posX = x;
        posY = y;
    }

    void position() {
        std::cout << posX << ", " << posY << std::endl;
    }


    // Destructor
    ~Player() {
        std::cout << "I'm being deleted!" << std::endl;
    }

private:
    void adjustSpeed() {
        // code
    }
};

int main() {
    Player player;
    player.posX = 5;

    player.position();
    player.~Player(); // Manual call.
}
```

### Inheritance

An Object Oriented Programming concept for creating classes that provide common
functionality and members for child classes to inherit.

```c++
class Entity {

public:
    int x, y;

    void move(int xa, int ya) {

    }
};

class Player : public Entity {

public:
    const char* name;

    void printName() {
        std::cout << name << std::endl;
    }
}

int main() {
    Player player;
    player.move(5, 5);
    player.printName();
}
```

### Structs

Structs and classes are essentially the same. One notable difference is visibility. Classes are
private by default, their data and functionality _cannot_ be accessed outside the class. Structs
are public by default, data and functionality _can_ be accessed outside the class. That's the
only difference.

However, they are used in different cases, depending on the person.

* structs - simple grouping of data/functions
* classes - more complex grouping of data/functions with the idea of inheritance/generics in mind

This is the recommended way to view these types

* You can use structs with inheritance (not recommended)
* You can inherit a class from a struct and vice-versa, will result in compiler warnings (not recommended)

> The reasoning for having structs is for C++ to maintain compatibility with C.

### Static

The `static` keyword has a different meaning when used within a class/struct, outside a class
struct. or withing a local scope.

1. **Inside a class/struct** - `static` means that the static member will share data with
all instances of this class. In other words, the variable belongs to the class instead of the
individual object and only once instance of that variable will be created.

1. **Outside a class/struct** - `static` signals to the linker that this symbol should
only be linked internally within the current object file. It makes the variable _private_ to the
file. So trying to access the variable outside the file with `extern` will throw a linking error.

1. **Local scope (functions/conditionals/loops)** - ``static` essentially makes the variable
defined in these scopes into a global variable that's only accessable **within** that scope. On
the first call, the static variable is initialized, subsequent calls will ignore the
initialization of the variable. The variable _belongs_ to the scope.

```c++
class ClassName {

    static int s_StaticVar = 10; // This variable is shared across all instances.

    int field1 = 0
    // Fields are private by default, but can be specified.
    private:
        int num1 = 1;
        int num2 = 2;
    public:
        int pNum1 = 3;
        int pNum2 = 4;

    // These access modifiers can be specified multiple times. Style is programmer preference.
    private:
        void methodOne() {
            // code
        }

    public:
        // Constructor
        ClassName() {

        }

        int methodTwo(int x, int y) {
            return x + y;
        }

        // Static methods can be called without a class instance, but can only reference static
        // variables. Since non static variables belong to entities, and static variables belong
        // to the class, static functions don't know non static variables. They don't know which
        // entity's variables to use. So they can't be used in static methods.
        static void staticMethod() {
            std::cout << s_StaticVar << std::endl;
        }
}; // Note the semicolon
```

## Language Specifics

With `#include` the argument is enclosed in `<>` or `""`.

* `<>` - search for file in include path folders.
* `""` - search for file in folders both relative to current directory and
include path folders.

> Files from the C standard library are usually using .h and the C++ standard
library has no extension.

### Header Files

Header files are meant to have declarations and constants that can be included
in various C++ files.

Most Header files begin with `#pragma once` which means to include this file only
once per object file. This helps prevent duplicate code which can cause linking
errors.

`#pragma once` is a commonly used header guard, before it was supported by most
compilers, the following structure was used:

```cpp
#ifndef _SOME_VAR
#define _SOME_VAR

// Declarations

#endif
```

## Libraries & Frameworks
