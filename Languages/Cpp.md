# C++

C++ is a low-level powerful programming language.

TODO:

* [Checkpoint](https://www.youtube.com/watch?v=ezqsL-st8qg&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=37)
* [VirtualFunctions](####Overriding) - [Video](https://www.youtube.com/watch?v=oIV2KchSyGQ&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=28)
* [Interfaces](####Interfaces) - [Video](https://www.youtube.com/watch?v=UWAdd13EfM8&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=29)

## Basics

* Anything prepended with a `#` is preprocess statement, which are processed by
a compiler right before compiling.
* The main function specifies a return type, but a return isn't required and
defaults to return 0.
* It is important to remember that files do not matter in C++, unlike languages
like Java where class names are tied to their file names. All files do in C++ is
feed the compiler source code.
* Declarations are stored in header files, and definitions are stored in C++
files.

### The Compiler & Linker

There are two steps to make a text file into a runnable program:

#### Compiling

Converts C++ code into an intermediate format known as an object file (one for
each C++ file).

1. Compilation starts by preprocessing the code by evaluating [preprocess statements](#Preprocess%20Statements)
    * `#include` - just copies and pastes whatever was in that header file.
    * `#define` - replaces the all found cases of the first argument with the
    second
    * `#if/#endif` - include/exclude code in compilation based on a condition
    * `#ifndef/#endif` - checks if there is a symbol defined from `#define`
    * `#pragma` - instruction sent to the preprocessor, `#pragma once` means to
    only include this file once in a single object file
1. Tokenize/Parse into an abstract syntax tree (which the compiler can
understand more easily)

The object files when opened just display binary, but you tell the compiler to
generate Asembly or other file types while compiling.

Compiler settings can also be user defined, by default, the compiler knowns how
to compile files based on extension. You can tell the compiler to compile `.foo`
files as C++ files and it will work just fine.

> Compilation errors are prepended with with a C.

#### Linking

Links the objects files generated by the compiler together (by resolving symbol
and function locations) into a runnable program.

Since files are not important in C++, and all object files get linked
together, this can cause some issues:

1. Having a function in a header file included in two other files will producea
linking error due to duplicate function names.
    * To fix this, `static` marks that symbol/function visible to only that
    object file.
    * Using `inline` marks that symbol/function to replace the calls with the
    symbol/function body.
    * Best method is to include the symbol/function definition in a C++ file to
    be used and use a declaraction in other files using that symbol/function.

> Linking errors are prepended with an L.

#### Declaractions & Defintions

* Declaraction - function signature to tell the compiler it exists in another
object file
* Definition - the actual function body

It is possible to compile code while having a definition in another C++ file, as
long as a declaration is made (A promise to the compiler that this function does
exist).

main.cpp

```c++
void Hello(const char* message); // Declaraction
extern int globalVar; // External linking of a variable outside this file.

int main() {
    Hello("Jerry");
    std::cout << globalVar << std::endl;
}
```

hello.cpp

```c++
#include <iostream>

int globalVar = 5; // Variable definition

// Definition
void Hello(const char* name) {
    std::cout << "Hello " << name << "!" << std::endl;
}

// Produces a
// void Hellow(const char* name) {
//     std::cout << "Hello " << name << "!" << std::endl;
// }
```

This is where the linker comes in, since there is an object file generated for
each C++ file, the linker links these object files together. However, if a
definition isn't found by the linker, this results in a **Linker Error**.

## Variables

Variables are strongly typed (needs to include data type).

`int number = 4;`

> int is 4 bytes = 32bits - 1 signed bit = 2(possible states)^31bits = ‭2,147,483,648‬ (int limit)

To completely remove the use of the signed bit, use `unsigned`

`unsigned int number = 4;`

Common types:

* `char` - 1 byte
* `short` - 2 bytes
* `int` - 4 bytes
* `long` - 4 bytes (depending on compiler)
* `long long` - 8 bytes
* `float` - 4 bytes (treated as a double unless prepended with `f`)
* `double` - 8 bytes
* `bool` - 1 byte

> Even though booleans can be stored in one bit, it occupies a byte since when
addressing memory, we can only address bytes, not bits. Nice little hack, it is
possible to store 8 bools in one byte!

### Pointers

A pointer is just an integer in hexadecimal format that holds a memory address.
Types don't matter with pointers. A pointer for all types is just the integer
that holds the memory address. Giving a pointer a type is telling the programmer
that the data in that address is presumed to be that type. It has no effect on\
what the pointer is: **an integer memory address**.

Simple pointer:

```c++
/* These are all the same. */

void* ptr = 0; // Not a valid memory address.
void* ptr2 = NULL; // #define value for 0.
void* ptr3 = nullptr; // Value introduced in C++11.
```

To grab the memory address of a variable, you use the `&` operator. If you want to access the
data, you would use the `*` to **dereference** the pointer (gain access to read and write to
that data). This is where types are also important, the compiler needs to know, how many bytes
can be written. An int pointer tells the compiler that there's 4 bytes there.

```c++
int num = 12;

int* numPtr = &num; // This is a memory address to 4 bytes.

// Dereference the pointer
*numPtr = 7;
```

Since pointers themeselves are integer variables representing a memory address, they also take
up memory. Therefore, the pointer itself has a memory address that can also be stored as a
pointer. This is where _double pointers_ come in.

```c++
int num = 5; // holds 5
int* numPtr = &num; // holds the value 0x61ff04 which -> 5
int** numPtrPtr = &numPtr; // holds the value 0x61ff00 which -> 04 ff 61 00 (0x61ff04)
```

Other useful examples with pointers:

```c++
// Chars are 1 bytes, but this is asking for 8 bytes and holding the memory address of the first byte
char* buffer = new char[8];

// memset fills a block of memory with data.
memset(buffer /*pointer*/, 0 /*What data*/, 8 /*How many bytes*/);

// Deletes the memory at that address using array notation (buffer was made with an array).
delete[] buffer;

// Declaring multiple pointers on one line.
int* ptr1, ptr2; // Error: ptr1 is an int pointer, ptr2 is an int.
int *ptr1, *ptr2; // Fix: Both are pointers.
```

#### Pointer Arithmetic

Pointer arithmetic is used to modify the memory address to point to other memory addresses using
arithmetic. Instead of manually adding bytes, the byte count is determined by the pointer's type.
So for an `int*` adding 1 to the pointer adds 4 bytes.

### References

References are pointers in disguise. It's not really a variable that takes up memory. It's
mostly syntatic sugar to alias a variable.

```c++
int a = 5;
int& ref = a;
ref = 2;

std::cout << a << std::endl; // Prints 2.
```

A simple example of why this is useful:

```c++
void Increment(int value) {
    value++;
}

void IncrementWithPtr(int* value) {
    // value++; // Increments the memory address
    // *value++; // Increments the memory address then dereferences the pointer (Order of operations)
    (*value)++; // Correct
}

void IncrementWithRef(int& value) {
    value++;
}

int main() {
    int a = 5;
    // Passing variable by value, it is copied then incremented.
    Increment(a);
    std::cout << a << std::endl; // Prints 5.

    // Passing by reference using pointers.
    IncrementWithPtr(&a);
    std::cout << a << std::endl; // Prints 6.

    // Using references (no need to send memory address, dereferance, and looks cleaner)
    IncrementWithRef(a);
    std::cout << a << std::endl; // Prints 6.
}
```

References are just aliases, not actual values. Everything you can do with a reference can be
done with a pointer. Pointers are just more powerful, but it's recommended to use references
when you can get away with using them.

> Once a reference is declared, what it references cannot be changed.

```c++
int a = 1;
int b = 5;

int& ref = a;
ref = b; // a = 5, b = 5

// Pointers make this behaviour possible.
int* ptr = &a; // *ptr = 1
ptr = &b; // *ptr = 5
```

### Strings

Strings are basically an array of characters. The string literal of
`"some string"` is treated as a `const char` array. Also, string literals
are **always** stored in read-only memory.

#### C Style Strings

To make a C-style string, `const char*` is commonly used. Using `const char*` provides a more
consistent behavior throughout C++ compilers. Since some compilers allow `char*` strings
to be modified while others will raise an error. Since there's no standardization of what should happen in this situation, it is known
as _undefined behavior_. Never write code like this.

```c++
// Undefined behavior, might compile, might throw an error.
char* name = "Jerry";
name[1] = 'a';
std::cout << name << std::endl; // Jerry

// Workaround
char[] name = "Jerry";
name[1] = 'a';
std::cout << name << std::endl; // Jarry
```

Since we're allocating a fixed block of memory, we don't want to be changing it carelessly.
Strings created this way can't just be made bigger with since the allocation is fixed. Using
`const` is a good reminder to keeping these things in mind.

Strings also end with the byte `00` which is known as the _null termination character_.
This is used to mark the end of a string.

```c++
const char* example = "C Style String";
char example2[14] = { 'C', ' ', 'S', 't', 'y', 'l', 'e', ' ', 'S', 't', 'r', 'i', 'n', 'g' };

//char example3[15] = { 'C', ' ', 'S', 't', 'y', 'l', 'e', ' ', 'S', 't', 'r', 'i', 'n', 'g', 0 };
char example3[15] = { 'C', ' ', 'S', 't', 'y', 'l', 'e', ' ', 'S', 't', 'r', 'i', 'n', 'g', '\0' };

std::cout << example << std::endl; // C Style String
std::cout << example2 << std::endl; // C Style StringeP@ (because no null character specified)
std::cout << example3 << std::endl; // C Style String

// C functions
int size = strlen(example);
// strcpy()
```

Other `char` data types:

```c++
const char* str = u8"string"; // 1-byte char string, u8 prefix is optional.
const wchar_t* str2 = L"string"; // 1/2/4-byte char string, platform/compiler dependent.
const char16_t str2 = u"string"; // 2-byte char string.
const char32_t str2 = U"string"; // 4-byte char string.
```

#### Standard Strings

Standard strings that are included in the standard library are commonly used.
The standard library also has functions to work with these strings. 

> To output these strings, you need to include the string header file.
You can create them without the header file, but you can't display
standard strings since the override for `<<` is in the string header file.

```C++
#include <string>

std::string example = "Standard Library String";

int size = example.size();
// Returns the start position of the const char array or std::string::npos.
bool contains = example.find("Library") != std::string::npos;

std::cout << example << std::endl;
```

With concatenating strings, it's important to keep in mind that `""` refers to const char
arrays. **not** strings. So trying to do something like `std::string message = "A " + "String";`
will not work, since you can't just add to char arrays together. Some alternative to concatenate
standard library strings:

```c++
std::string example = "Standard Library";
example += " String";

std::string example2 = std::string("Standard Library") + " String";

std::cout << example << std::endl;
std::cout << example2 << std::endl;
```

Passing strings around into functions, keep in mind the behavior of passing by reference or by
value.

```c++
#include <string>
// This would create a copy of str, any modifications done will not be reflected on the original.
// Memory-wise, this is inefficient.
void printStringByValue(std::string str) {
    std::cout << str << std::endl;
}

// It is recommended to pass read-only strings by a const reference.
// Reference means it won't be copied and const means we promise not to modify it.
void printStringByRef(const std::string& str) {
    std::cout << str << std::endl;
}

int main() {
    std::string message = "Hello, world!";

    printStringByValue(message);
    printStringByRef(message);
}
```

Other string literals can be used in the `string_literals` library.

```c++
using namespace std::string_literals;

// s is a function to convert const char array to a standarad string.
std::string msg = "Hello, "s + "World";

// Raw strings, useful for multiline strings and ignoring escape charactes.
const char* example R"(
    Line1
    Line2
    Line3
)"

// Multiline string without using raw strings.
const char* example = "Line1\n"
"Line2\n"
"Line3\n";
```

## Conditionals

Syntax:

```c++
if(condition) {
    // code
}
else if(condition) {
    // code
}
else {
    // code
}

// What really happens with 'else if'

if(condition) {

}
else {
    if(condition) {

    }
}

// Ternary Operator
int level = 1;

std::string rank = level > 10? "Master" : "Beginner";
```

Conditional operators: `== != < > <= >= && || !`

## Collections

Arrays are a collection of elements of the same type. Arrays are just a pointer to the block of
allocated memory.

```c++
int numbers[5];

numbers[0] = 5;
numbers[4] = 2;

int* p_numbers = numbers; // Works fine since arrays are just pointers.

// Using pointer arithmetic to set a value
// numbers[2] = 10;
*(p_numbers + 2) = 10;
```

## Loops

C++ supports `while`, `do while`, and `for` loops.

while syntax:

```c++
int i = 0;
while(i < 10) {
    // code
    i++;
}


```

do while syntax

```c++
int i = 0;
do {
    // code
    i++;
} while(i < 10);

```

for syntax:

```c++
for(int i = 0; i < 10; i++) {
    // code
}

// These also work
int i = 0;
for( ; i < 10 ; ) {
    // code
    i++;
}

int i = 0;
bool condition = i < 10;
for( ; condition ; ) {
    // code
    i++;
}
```

Control flow statements are used with loops to affect the flow of the loop.

* `break` - end the loop
* `continue` - go to the next iteration if there is, otherwise finish the loop.
* `return` - exits the function
* `goto` -

## I/O

## Functions

Syntax:

```c++
void myFunction(int param1, int param2) {
    // code
}

myFunction();
```

### Lambdas

## Exceptions

## Classes & Objects

Classes and objects allow for a type of programming known as Object Oriented Programming. They
allow for the grouping of data and functionality. C does not support OOP, however, C++ added
those features. It's important to keep in mind that anything you can do with classes can be done
without classes. Hence why C is still a usable language. Classes just make code easier to
organize and maintain.

Simple class example:

```c++
class Player {

    // Class members are private by default.
    int x, y;
    int speed;

    void position() {
        std::cout << posX << ", " << posY << std::endl;
    }

};
```

### Access Modifiers

Access modifiers are used to specify from where class members can be accessed from.

* `public` - accessable from anywhere
* `protected` - accessable to the class and subclasses
* `private` - only accessable to the class (and a Friend class?)

Access modifiers affect both class fields and methods. They can be placed
in more than one place in the class declaration, it depends on the programmers
style.

```c++
class Player {

public:
    int posX = 3;
    int posY = 4;
private:
    int p_SpeedX = 1;
    int p_SpeedY = 2;

public:
    void position() {
        std::cout << posX << ", " << posY << std::endl;
    }

private:
    void adjustSpeed() {
        // code
    }
};

int main() {
    Player player;
    player.posX = 5;

    player.position();
}
```

### Constructors

Constructors are methods called when you initialize and object. There is a
default constructor provided, but it's just a method with an empty body.

```c++
class Player {

public:
    int posX;
    int posY;
private:
    int p_SpeedX = 1;
    int p_SpeedY = 2;

public:
    // Constructor.
    Player(int x, int y) {
        posX = x;
        posY = y;
    }

    void position() {
        std::cout << posX << ", " << posY << std::endl;
    }

private:
    void adjustSpeed() {
        // code
    }
};

int main() {
    Player player(3, 4);
    player.position();
}
```

There is a way to remove constructor functionality from a class (common for
classes with only static methods, where objects don't need to be instantiated)

You can make the constructor private or use the `delete` keyword.

```c++
class Log {
// Method 1.
private:
    Log() {}
public:
    // Method 2
    Log() = delete;
    void Write() {

    }
}
```

#### Constructor Initializer List

Provides a way to initilalize class members outside of the body of the constructor.
They help keep the constructor's body clean, and performance-wise they prevent memory
leaks by ensuring that only one object is created instead of two. You can also
initialize `const` variables using initilizer lists.

Example:

```c++
class Entity {

private:
    std::string m_Name;
    int m_Score;

public:

    // Example 1
    Entity() {
        m_Name = "Unknown";
    }
    Entity()
        : m_Name("Unknown"), m_Score(0) {

    }

    // Example 2
    Entity(const std::string& name) {
        m_Name = name;
    }
    Entity(const std::string& name)
        : m_Name(name) {

    }
}
```

Memory leak example (Primitive data types don't experience this type of issue):

```c++
class Kiwi {

public:
    Kiwi() {
        std::cout << "Created a Kiwi!" << std::endl;
    }

    Kiwi(int x) {
        std::cout << "Created a Kiwi with " << x << "!" << std::endl;
    }
}

class Lunch {
    
private:
    std::string m_Name;
    // Creates a Kiwi with a call to Kiwi()!
    Kiwi m_Kiwi;

public:
    Lunch() {
        m_Name = "Jerry";
        // Creates a second kiwi with Kiwi(int x)!
        m_Kiwi = Kiwi(4);
    }

    // Only one object instance is created with initializer lists!
    Lunch()
        : m_Kiwi(Kiwi(4)) {
        
        m_Name = "Jerry";
    }
    Lunch()
        : m_Kiwi(4) {
        
        m_Name = "Jerry";
    }

}

```

> Note: The variable declarations and the initializer list **must** be declared in the
same order.

#### Copy Constructors

#### Move Constructors

### Destructors

Destructors are called when an object gets destroyed. It's used for preventing
memory leaks. Best practice is to uninitialize everything that was initialized in
the constructor.

```c++
class Player {

public:
    int posX = 3;
    int posY = 4;
private:
    int p_SpeedX = 1;
    int p_SpeedY = 2;

public:
    // Constructor.
    Player(int x, int y) {
        posX = x;
        posY = y;
    }

    void position() {
        std::cout << posX << ", " << posY << std::endl;
    }


    // Destructor
    ~Player() {
        std::cout << "I'm being deleted!" << std::endl;
    }

private:
    void adjustSpeed() {
        // code
    }
};

int main() {
    Player player;
    player.posX = 5;

    player.position();
    player.~Player(); // Manual call.
}
```

### Inheritance

An Object Oriented Programming concept for creating classes that provide common
functionality and members for child classes to inherit.

```c++
class Entity {

public:
    int x, y;

    void move(int xa, int ya) {

    }
};

class Player : public Entity {

public:
    const char* name;

    void printName() {
        std::cout << name << std::endl;
    }
};

int main() {
    Player player;
    player.move(5, 5);
    player.printName();
}
```

#### Overriding

### Structs

Structs and classes are essentially the same. One notable difference is visibility. Classes are
private by default, their data and functionality _cannot_ be accessed outside the class. Structs
are public by default, data and functionality _can_ be accessed outside the class. That's the
only difference.

However, they are used in different cases, depending on the person.

* structs - simple grouping of data/functions
* classes - more complex grouping of data/functions with the idea of inheritance/generics in mind

This is the recommended way to view these types

* You can use structs with inheritance (not recommended)
* You can inherit a class from a struct and vice-versa, will result in compiler warnings (not recommended)

> The reasoning for having structs is for C++ to maintain compatibility with C.

## Language Specifics

### Preprocess Statements

Preprocess statements are bits of code evaluated before compiling. Some commonly
used preprocess statements are:

* `#include` - just copies and pastes whatever was in that header file.
* `#define` - replaces the all found cases of the first argument with the
    second
* `#if/#endif` - include/exclude code in compilation based on a condition
* `#ifndef/#endif` - checks if there is a symbol defined from `#define`
* `#pragma` - instruction sent to the preprocessor, `#pragma once` means to
    only include this file once in a single object file

With `#include` the argument is enclosed in `<>` or `""`.

* `<>` - search for file in include path folders.
* `""` - search for file in folders both relative to current directory and
include path folders.

> Files from the C standard library are usually using .h and the C++ standard
library has no extension.

### Header Files

Header files are meant to have declarations and constants that can be included
in various C++ files.

Most Header files begin with `#pragma once` which means to include this file only
once per object file. This helps prevent duplicate code which can cause linking
errors.

`#pragma once` is a commonly used header guard, before it was supported by most
compilers, the following structure was used:

```c++
#ifndef _SOME_VAR
#define _SOME_VAR

// Declarations

#endif
```

### Multi-use Keywords: const & static

#### The const keyword

The `const` keyword can be used in multiple locations and has a different effect on where
it's used: 

* Before the `*`, makes the pointer value constant
* After the `*`, makes the pointer itself constant
* After a class method signature, marks the method as read-only, it cannot modify class
members

```c++
// Value pNum is pointing to cannot be modified.
const int* pNum;
int const* pNum;

// The pNum pointer itself cannot be modified.
int* const pNum2;

// The pNum3 value and pointer itself cannot be modified.
const int* const pNum3;

class Entity {

private:
    int y, x;

public:
    // Read-only method.
    int getX() const {
        // x = 2; // Will throw an error.
        return x;
    }

    // Read-only method returning a non-modifiable pointer with a non-modifiable value.
    const int* const getY() const {
        return y;
    }

}
```

##### mutable

The `mutable` keyword can be used to _break_ the promise of `const` within a class:

```c++
class Entity {

private:
    mutable int counter;
    int y, x;

public:
    // Read-only method.
    int getX() const {
        // x = 2; // Will throw an error.
        counter++; // mutable, so no error!
        return x;
    }

}
```

It is also used with [lambdas](#Lambdas) for a cleaner look when passing arguments in by 
value.

#### The static keyword

The `static` keyword has a different meaning when used within a class/struct, outside a class
struct. or withing a local scope.

1. **Inside a class/struct** - `static` means that the static member will share data with
all instances of this class. In other words, the variable belongs to the class instead of the
individual object and only once instance of that variable will be created.

1. **Outside a class/struct** - `static` signals to the linker that this symbol should
only be linked internally within the current object file. It makes the variable _private_ to the
file. So trying to access the variable outside the file with `extern` will throw a linking error.

1. **Local scope (functions/conditionals/loops)** - ``static` essentially makes the variable
defined in these scopes into a global variable that's only accessable **within** that scope. On
the first call, the static variable is initialized, subsequent calls will ignore the
initialization of the variable. The variable _belongs_ to the scope.

```c++
class ClassName {

    static int s_StaticVar = 10; // This variable is shared across all instances.

    int field1 = 0
    // Fields are private by default, but can be specified.
    private:
        int num1 = 1;
        int num2 = 2;
    public:
        int pNum1 = 3;
        int pNum2 = 4;

    // These access modifiers can be specified multiple times. Style is programmer preference.
    private:
        void methodOne() {
            // code
        }

    public:
        // Constructor
        ClassName() {

        }

        int methodTwo(int x, int y) {
            return x + y;
        }

        // Static methods can be called without a class instance, but can only reference static
        // variables. Since non static variables belong to entities, and static variables belong
        // to the class, static functions don't know non static variables. They don't know which
        // entity's variables to use. So they can't be used in static methods.
        static void staticMethod() {
            std::cout << s_StaticVar << std::endl;
        }
}; // Note the semicolon
```

## Libraries & Frameworks
